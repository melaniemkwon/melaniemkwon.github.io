---
layout: post
title: Code and Forget, Code and Forget
tags: [code]
categories:
- blog
---

## We build our computers the way we build our cities - over time, without a plan, on top of ruins.

I wanted to share this beautiful piece of writing from Ellen Ullman's biography, *Life in Code*.

> I used to pass by a large computer system with the feeling that it represented the 
> summed-up knowledge of human beings.
> It reassured me to think of all those programs as a kind of library in which our 
> understanding of the world was recorded in intricate and exquisite detail.
> I managed to hold on to this comforting belief even in the face of years in the
> programming business, where I learned from the beginning what a hard time we programmers
> have in maintaining our own code, let along understanding programs written and
> and modified over years by untold numbers of other programmers. Programmers come 
> and go; the core group that once understood the issues has written the code
> and moved on; new programmers have come, left their bit of understanding in the
> code, and moved on in turn. Eventually no one individual or group knows the full
> range of the problem behind the program, the solutions we chose, the ones we rejected
> and why.

<img src="/assets/images/cobol.jpg" alt="cobol" style="max-width: 100%">

> Over time, the only representation of the original knowledge becomes the code
> itself, which by now is something we can run but not exactly understand. It has 
> become a process, something we can operate but no longer rethink deeply. When
> knowledge passes into code it changes state; like water turned to ice, it becomes
> a new thing, with new properties. We **use** it; but in a human sense we no longer **know** it.

<img src="/assets/images/glacier.jpg" alt="glacier" style="max-width: 100%">

> The year-2000 problem is an example on a vast scale of knowledge disappearing into code.
> And the soon-to-fail national air-traffic-control system is but one stark instance
> of how computerized expertise can be lost. In March 1998, The New York Times reported
> that IBM had told the Federal Aviation Administration that, come the millennium, the 
> existing system would stop functioning reliably. IBM's advice was to replace the system
> completely, because, they said, there was "no one left who understands the inner
> workings of the host computer."

> **No one left who understands**. Air-traffic control systems, bookkeeping, drafting,
> circuit design, spelling, assembly lines, ordering systems, network communications,
> rocket launchers, atom-bomb silos, electric generators, operating systems, fuel injectors,
> CAT scans - an exploding list of subjects, objects, and processes rushing into code which
> eventually will be left running without anyone left who understands them. A world
> floating atop a sea of programs we've come to rely on but no longer truly control.
> Code and forget, code and forget: programming as a collective exercise in incremental
> forgetting.

That's a scary thought isn't it? Back in grad school, I had a CS professor who would  
fondly recount a story of a software engineer he used to work with at JPL. Although 
a reknowned expert in flight software safety, she herself would refuse to ever
board a plane because she knew too much about the flaws and bugs in the system.
And that's for software that is *well-understood*. What about all the forgotten, 
abandoned code quietly running on machines day to day, that nobody remembers?

<img src="/assets/images/glados.jpg" alt="glados" style="max-width: 100%">